#!/usr/bin/perl

##
# The SpaceFree agent:
#   - tries to relocate to specified hosts and find out how much space
#     is on each host.  When it gets to the last host in the list, it
#     prints out a summary.  Only works on UN*X [namely Linux] machines.
#   - Arguments:
#	Hosts => ['host1.ip.addr[:port]', ... 'hostn.ip.addr[:port]']
#	verbose => self evident
#   - Steve Purkis <spurkis@engsoc.carleton.ca>, April 30, 1998.
##

# NOTE: AN AGENT'S GLOBAL VARIABLES ARE **NOT** PERSISTANT!!
# Only those stored in $self are!
# Programming an agent is like programming a recursive function.

package Agent::SpaceFree;
use Agent;
@ISA = qw( Agent );

sub new {
	my ($class, %args) = @_;
	my $self = {};
	foreach (keys(%args)) { $self->{"$_"} = $args{"$_"}; }
	bless $self, $class;
}

sub agent_main {
	my ($self, @args) = @_;
	my $to = \$self->{To};

	print "To: $$to\n" if $self->{verbose};
	if ($$to) {
		${$self->{Space}}{$$to} = $self->space();
	}

	unless ($self->{To} = shift @{$self->{'Hosts'}}) {
		return $self->summary();
	}

	# [attempt] jump to next host:
	print "Jumping to $$to... " if $self->{verbose};
	my $msg = new Agent::Message(
		Body      => [ "Run me\n", $self->store() ],
		Transport => TCP,
		Address   => $$to
	);
	$msg->send;
	print "done.\n";
}


sub space {
	my ($self, @args) = @_;

	my $space;
	if ($^O =~ /linux/i) {
		@df = `df -h`;
		shift @df;	# lose the header
		foreach (@df) {
			if ($_ =~ /\S+\s+\S+\s+\S+\s+([\d\.]+)M/) {
				$space += $1;
			}
		}
	} elsif ($^O =~ /win32/i) {
		# not yet.
	}

	$space .= "Mb free";
	print "Space: $space\n" if $self->{verbose};
	return $space;
}

sub summary {
	my ($self, @args) = @_;

	print "+------\n|SpaceFree Agent summary:\n";
	foreach (keys(%{$self->{Space}})) {
		print "|\t$_ =>\t", ${$self->{Space}}{$_}, "\n";
	}
	print "+------\n";
}

1;

